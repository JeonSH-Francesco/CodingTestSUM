def solution(number, k):
    stack = []
    for digit in number:
        # 숫자 k개를 제거할 때까지 조건에 맞게 제거
        while k > 0 and stack and stack[-1] < digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    
    # k개를 다 제거했다면, 나머지 숫자에서 마지막 k개를 잘라냄
    return ''.join(stack[:len(stack) - k])


print(solution("1924", 2))  
print(solution("1231234", 3))  
print(solution("4177252841", 4))  

'''
numbers="1924", k=2인 경우.

첫 번째 반복: 
숫자 1을 확인합니다.
stack이 비어 있으므로 1을 stack에 추가합니다.
stack=["1"]

두 번째 반복:
숫자 9를 확인합니다.
stack의 마지막 숫자 1보다 9가 크므로 1을 제거하고 9를 추가합니다.
stack=["9"]
k=1

세 번째 반복:
숫자 2를 확인합니다.
stack의 마지막 숫자 9보다 2가 작으므로 
stack=["9","2"]
k=1

네 번쨰 반복:
숫자 4를 확인합니다.
stack의 마지막 숫자 2보다 4가 크므로 2를 제거하고 4를 추가합니다.
stack=["9"."4"]
k=0 (이제 더 이상 제거하지 않음.)

최종 결과:
stack=["9"."4"]
남은 숫자들로 결합하여 "94"를 반환합니다.
정확한 최종 결과: "94"
------------------------------------------
number = "1231234", k = 3인 경우.

첫 번째 반복:
숫자 1을 확인합니다.
stack이 비어 있으므로 1을 stack에 추가합니다.
stack = ["1"]

두 번째 반복:
숫자 2를 확인합니다.
stack의 마지막 숫자 1보다 2가 크므로 1을 제거하고 2를 추가합니다.
stack = ["2"]
k = 2

세 번째 반복:
숫자 3을 확인합니다.
stack의 마지막 숫자 2보다 3이 크므로 2를 제거하고 3을 추가합니다.
stack = ["3"]
k = 1

네 번째 반복:
숫자 1을 확인합니다.
stack의 마지막 숫자 3보다 1이 작으므로, 1을 stack에 추가합니다.
stack = ["3", "1"]

다섯 번째 반복:
숫자 2를 확인합니다.
stack의 마지막 숫자 1보다 2가 크므로 1을 제거하고 2를 추가합니다.
stack = ["3", "2"]
k = 0 (이제 더 이상 숫자를 제거하지 않음)

여섯 번째 반복:
숫자 3을 확인합니다.
k가 0이므로 더 이상 제거하지 않고, 3을 stack에 추가합니다.
stack = ["3", "2", "3"]

일곱 번째 반복:
숫자 4를 확인합니다.
k가 0이므로 더 이상 제거하지 않고, 4를 stack에 추가합니다.
stack = ["3", "2", "3", "4"]

최종 결과:
stack = ["3", "2", "3", "4"]
남은 숫자들로 결합하여 "3234"를 반환합니다.
정확한 최종 결과: "3234"

마찬가지
'''
