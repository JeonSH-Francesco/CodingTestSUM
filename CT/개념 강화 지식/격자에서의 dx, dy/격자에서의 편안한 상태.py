'''
NxN 크기의 격자 위에 총 M번에 걸쳐 색칠을 진행합니다. 한 번에 한 칸만 색칠하며, 색칠을 한 직후에 해당 칸이 '편안한 상태'에 놓여 있는지를 확인하려 합니다.
'편안한 상태'란 방금 막 칠해진 칸을 기점으로 위 아래 양옆으로 인접한 4개의 칸 중 격자를 벗어나지 않는 칸에 색칠되어 있는 칸이
정확히 3개인 경우를 뜻합니다. 색칠한 칸이 주어질 때마다 해당 칸을 칠한 직후 막 칠한 칸이 편안한 상태에 있는지를 계속 알아내는 프로그램으로 작성해보세요.

입력)
첫 번째 줄에는 정수 N과 M이 주어집니다.
두 번째 줄부터는 M개의 줄에 걸쳐 각 줄마다 색칠한 칸의 위치(r,c)가 공백을 사이에 두고 주어집니다.
이는 r행 c열에 색칠해야 함을 의미하며, 색칠을 동일한 칸에 2번 이상 하게 되는 경우는 없다고 가정해도 좋습니다.

출력)
M개의 줄에 걸쳐 답을 출력합니다. 각 줄에 대해 해당 칸이 주어져 격자에 칠한 즉시, 해당 칸이 편안한 상태에 있다면 1, 아니라면 0을 출력합니다.
'''

n, m = map(int, input().split())
points = [tuple(map(int, input().split())) for _ in range(m)]

# 격자 초기화 (0: 안 칠해짐, 1: 칠해짐)
grid = [[0] * n for _ in range(n)]

# 방향: 우, 하, 좌, 상
dxs = [0, 1, 0, -1]
dys = [1, 0, -1, 0]

def in_range(x, y):
    return 0 <= x < n and 0 <= y < n

for r, c in points:
    x, y = r - 1, c - 1  # 1-based → 0-based
    grid[x][y] = 1       # 해당 칸 색칠

    cnt = 0
    for dx, dy in zip(dxs, dys):
        nx, ny = x + dx, y + dy
        if in_range(nx, ny) and grid[nx][ny] == 1:
            cnt += 1

    # 조건문으로 직접 출력
    if cnt == 3:
        print(1)
    else:
        print(0)
'''
4 8
1 2
2 1
2 3
2 2
3 3
4 2
3 2
4 3

->
0
0
0
1
0
0
1
0
'''
